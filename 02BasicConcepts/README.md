<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [2. 基本概念](#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [2.1 值与类型](#21-%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B)
  - [2.2 环境与全局环境](#22-%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83)
  - [2.3 错误处理](#23-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86)
  - [2.4 元表和元方法](#24-%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95)
  - [2.5 垃圾收集](#25-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86)
  - [2.6 协程](#26-%E5%8D%8F%E7%A8%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 2. 基本概念

## 2.1 值与类型

Lua是动态类型语言：
- 变量没有类型，只有值有类型，语言中没有类型定义，每个值都携带了自己的类型。
- 所有值都是第一类值，这意味着所有值都可以存储在变量中，可以作为参数传递到其他函数，作为返回值。
- 基本类型：`nil boolean number string function userdata thread table`。
- `nil`: 仅有一个值`nil`，通常用来表示一个值的缺失/不存在。
- `boolean`: `true false`, `nil false`作为条件都表示假，所有其他值都为真。`nil false`正常情况下很像，关键的不同点在于在表格(table)中`nil`表示key不能存在，`false`则表现得像一个正常值。
- `number`: 整数和浮点数，使用两个子类型`integer float`，标准Lua中前者64位整数，后者64位浮点。但是可以选择编译Lua时配置为32位整数和32位单精度浮点数，在嵌入式系统中可能会选择这样做。
    - 整数明确使用2的补码算术，浮点则是IEEE754。
    - 当两个子类型显式使用时有显式的规则，但是当需要时他们之间可以自动转换。
    - 程序员可以需要明确是忽略整数浮点差异还是精确手动控制类型。
- `string`: 表示一个不可变的字节序列，可以包含任何值，包括嵌入其中的空字节`\0`。编码无关，不对字符串内容做任何假设，长度必须能够保存为整数`integer`。
- `function`: Lua中可以调用用Lua或者C编写的函数，两者类型都是`function`。
- `userdata`: 使得任何C类型都可以保存在Lua变量中。一个`userdata`值表示一块原始内存。分为两类：
    - full userdata: 是由Lua进行内存管理的对象。
    - light userdata: 仅仅是一个C指针值。
    - `userdata`除了赋值和判等没有Lua预定义的方法。通过使用metatable，程序员可以为full userdata定义操作。
    - `userdata`值不能由Lua进行更改，而只能通过C程序中提供的API进行更改，这确保了宿主程序或者C库中的数据的正确性。
- `thread`: 表示一个独立的线程执行，用来实现协程（coroutine），Lua线程并不关联于操作系统线程。Lua在任何系统上都支持协程，即使在不支持线程的系统上。
- `table`: 实现了关联数组，除了整数也可以使用其他类型作为数组索引，除了`nil`和`NaN`（只IEEE754浮点数定义的NaN值，比如0/0就是NaN）。
    - 表格可以是异质的，可以保存任何类型的值（除了`nil`）。
    - 所有值为`nil`的键和表项都不被认为是表格的一部分。
- `table`是Lua中唯一的数据构造机制，可以用来表示普通数组、列表、符号表、集合、记录、图、树等。
    - 为了表示记录（对象），Lua使用域名称作为索引。Lua提供`a.name`作为`a["name"]`的语法糖。
    - 有很多种方便的方法创建`table`。
    - 就像索引一样，Lua中表格的值项也可以是任何类型。因为函数也是第一类值，所以也可以作为值保存在表格中，所以`table`也可以有方法。
    - `table`的索引遵循语言中原始等价性（raw equality）的定义，`a[i] a[j]`表示相同表格元素，只要`i j`是**raw equal**的（也就是**equal without metamethods**，尚需要这个词的准确定义和含义）。也就是说是一个整数的浮点数(`float`)和对应的整数(`integer`)是相等的（`1.0 == 1`）。更具体地说，所有值等于一个整数的浮点数，在被插入table时会被转化为一个整数，`a[2.0] = true`那么插入table中的键是整数2。
- `table function thread`和full userdata类型的值都是对象（object）：对象的变量都是引用类型，也就是他们都不实际包含这些值，而是一个指向这个对象实际内存的引用。
    - 赋值、参数传递、函数返回都是操作这些值的引用，不会造成任何拷贝。
- 库函数`type`返回一个描述一个给定值类型的字符串。

## 2.2 环境与全局环境

- 所有对一个没有绑定到任何声明的自由名称`var`的引用都会在语法上被翻译为`_ENV.var`。
- 而且每一个块（chunk）都会在一个名为`_ENV`的外部本地名称（external local variable）的作用域内编译，所以`_ENV`绝对不会在一个块内作为一个自由名称。（也就是说任何在一个块内的第一级名称`_ENV`都是对这个`_ENV`的引用，而不是一个嵌套的`_ENV._ENV`，如果你想要在这个环境内定义一个名称`_ENV`，那么需要显式使用`_ENV._ENV`）。
- 虽然这个外部的`_ENV`会被用在名称的翻译上，但是`_ENV`本身就是一个常规的名称，遵守通常的可见性规则（后续介绍）。
- 像`_ENV`这样使用的表格被称为环境（environment）。
- Lua有一个特殊的环境称之为全局环境（global environment）。这个值被保存在C注册表（C Registry，后续介绍）中的一个特殊索引中，Lua中的全局变量`_G`被初始化为同样的值。`_G`不会被Lua内部使用，更改这个值仅仅会影响你写的代码。
- 当Lua加载一个块（chunk）时，它的环境`_ENV`的默认值就是全局环境。因此，默认情况下，Lua代码中的自由名称指代的条目都在全局环境中，也可将他们称之为**全局变量**。
- 所有标准库都被加载到全局环境中。
- 可以使用`load/loadfile`函数将一个块加载一个不同的环境中。如果在C中，则需要加载一个块后使用`lua_setupvalue`更改第一个upvalue（what is this?）。

## 2.3 错误处理

- Lua中的很多操作都可以抛出错误，错误会中断程序的正常流程，错误可以被捕获。
- 通过调用`error`函数显式抛出错误，这个函数不会返回。
- 为了捕获一个错误，需要使用`pcall/xpcall`让一个函数运行在保护模式（protected mode）。错误抛出时中断函数执行，并将控制返回给`pcall`，`pcall`会返回一个状态码。
- 因为Lua是一个嵌入式的扩展语言，Lua代码通过宿主程序中的C代码启动（Lua独立实现则由lua程序启动）。通常来说，这个调用是保护模式下的，所以当一个错误抛出时，控制会返回到宿主程序，由宿主程序采取恰当措施，比如打印错误信息。
- 错误发生时，带着错误信息的错误对象被传播到捕捉点。Lua本身仅保证这个错误对象是一个字符串。但是在自己的Lua程序中可以生成任意值作为错误对象，这取决于Lua程序自身以及宿主程序中的错误处理逻辑。即是这个对象不是一个字符串，我们也通常将错误成为错误信息。
- 调用Lua中的`xpacall`或者C中的`lua_pcall`时可以给一个错误信息处理器（message handler）来处理错误。这个函数会在传入原始的错误对象后返回一个新的错误对象。
    - 这个函数会在栈回溯（stack unwinding）之前调用，可以获得更多有关错误的信息。比如通过检查栈来创建一个栈回溯（stack traceback）。
    - 这个函数同样是在保护模式下调用的，在错误处理器上发生的错误将会继续调用这个错误处理器进行处理。如果这种递归调用太长，那么Lua会中断它并返回合适的信息。
    - 错误处理器仅仅用来处理常规运行时错误，不会处理内存非配错误或者运行finilizer或者其他错误处理器是产生的错误。
- Lua同样提供了一个警告系统（a system of warnings），见`warn`函数。警告并不会以任何形式干扰程序执行，一般来说仅生成一条给用户的信息。但是这种行为可以通过C函数`lua_setwarnf`修改。

## 2.4 元表和元方法

- 每个Lua值都可以有一个元表（metatable），这个元表就是一个普通的Lua table，定义了一个值在一系列事件下的行为。
- 可以通过设定这个元表的特定域来修改对应行为。比如对一个非数值的值运行`+`的行为就可以通过设定`_add`来做到，如果有这个域，那么Lua通过调用这个函数来执行加法。（很像Python中的特殊方法，很多语言都提供这种机制）
- metatable中的事件名称都以两个下划线开头。对应的值成为元值metavalue，对于大多数事件，metavalue必须是方法，并称之为元方法metamethod。
- 可以通过`getmetatable`函数获取元表。Lua通过`rawget`从metatable中查找metamethod。
- 可以通过`setmetatable`函数设置table的metatable。不能通过Lua代码修改其他类型的metatable，除了通过使用debug库。
- table和full userdata对象有独立的metatable，尽管多个table和userdata可以共享他们的metatable。其他类型的值一个类型共享一个metatable。默认情况下，一个值没有metatable，string库给string类型设置了一个metatable。
- metatable的详细列表：按照约定，每个域都以两个下划线开头，然后跟小写字母：
    - `__add`：`+`运算符，如果其中一个操作数不是`number`，那么就会去尝试调用元方法。从第一个操作数开始查找（即是它是一个`number`），如果没有找到那么找第二个操作，将两个操作数做为函数参数来调用。如果没有找到，抛出一个错误。后续的算术运算`- * / % ^ - //`都类似。
    - `__sub`：`-`减法，二元。
    - `__mul`：`*`乘法。
    - `__div`：`/`除法。
    - `__mod`：`%`求模。
    - `__pow`：`^`求幂。
    - `__unm`：`-`符号，一元。
    - `__idiv`：`//`整除。
    - `__band`：`&`按位与，类似于加法，但是有一点区别就是如果两个都是`number`，那么其中如果有参数是`float`会被转换为`integer`。
    - `__bor`：`|`按位或。
    - `__bxor`：`~`按位异或，二元运算。（和C语言的运算符有差异，`^`变成了求幂）
    - `__bnot`：`~`按位取反，一元运算。
    - `__shl`：`<<`左移。
    - `__shr`：`>>`右移。
    - `__concat`：`..`拼接操作，二元。当其中有参数不是`string`或者`number`（运算时转换会为`string`）就会去查找元表。
    - `__len`：`#`取长度操作，一元，如果参数不是`string`，那么会查找元表。
    - `__eq`：`==`判等操作，二元。如果两个操作数都是`table`或者`userdata`而且经过判断不是直接相等，则会去查元表。否则直接查。结果将会被转为`boolean`，`> <`类似。
    - `__lt`：`>`比较操作，二元。
    - `__le`：`<`比较操作，二元。
    - `__index`：`table[key]`索引操作，二元，元表查找发生在不是`table`或者key不存在于`table`中时。元表中查找到的元值可以是一个函数、一个`table`或者一个具有`__index`元值的任何值。索引操作是常规操作，不是原始（raw）的，所以能够触发任何`__index`。
    - `__newindex`：索引加赋值`table[key] = value`。就像索引操作，当不是`table`或者key不存在时去查找。`table key value`三个参数。常规操作不是原始操作，类似`__index`，能够触发任何`__newindex`。赋值不会使用执行原始赋值（primitive assignment，what is this?），如果需要会调用`rawset`执行赋值。
    - `__call`：`func(args)`操作，当`func`不是一个函数时执行元表查找。两个参数`func args`。这个调用的所有结果作为返回值。**这是唯一允许多个结果的元方法**，前面的如果是函数调用都会被调整为一个值（how? pick up first one?）。
- 对于其中的一元运算符（负号、长度、按位取反），对应的元方法会被传入第二个占位操作数，这个操作数和第一个操作相等。这个额外参数仅仅是为了简化Lua的内部实现，让这个操作数表现得像一个二元操作符。
- 除了以上条目，解释器还支持以下的键：
    - `__gc`
    - `__close`
    - `__mode`
    - `__name`：当其中保存一个string时，可以被用在`tostring`和错误消息中。
- 因为metatable也是一个常规的table，所以也可以包含任意的域，除了上述的域之外。一些标准库中的函数会使用其他域，用于自己的目的。
- 最佳实践：
    - 在将metatable设置给对象之前就将所有需要的metamethod添加到其中。特别地，`__gc`元方法只有在这种情况下才能工作。
    - 最好在创建一个对象之后就设置它的metatable。

## 2.5 垃圾收集

垃圾收集：
- Lua具有自动内存管理，也就是垃圾收集机制（GC）。
- 所有Lua使用的内存都会进行自动内存管理，所有死亡的（dead）对象都会被回收。
- 一个对象如果在正常执行过程中绝对不会再被访问到就会被认为是死亡（dead）。这里的正常执行包括finalizer，在其中会复活死亡的对象，并且这里的正常操作排除了调试库中的操作。
- 注意Lua的GC仅有的保证是：
    - 还能够被访问的对象（依然有有引用指向对象）不会被收集。
    - 并且无法访问的对象最终会被收集。
- 注册表能够访问的C代码中的对象不会被收集，这包括全局环境。
- Lua的GC可以工作在两种模式下：**增量式**（incremental）或者**分代式**（generational）。
- GC的默认模式大部分情况就足够了，但不一定是最优。
- 一些设置会对垃圾收集的效率有影响。但一定注意**垃圾收集设置对性能的影响即不跨平台也不跨Lua版本**，所以一个最优的Lua垃圾收集设置是不可移植的。
- 可以使用C接口`lua_gc`或者Lua函数`collectgarbage`修改GC模式和参数。也可以使用这些函数直接控制垃圾收集器（比如停止并重启垃圾收集器）。

**增量式垃圾收集**：
- 在增量式模式下，每个GC循环会小步骤执行一次标记扫描收集算法，这些步骤会穿插在程序执行过程中。
- 这种模式下有三个参数来控制GC的循环：

|参数|含义|
|:-|:-|
|the garbage-collector pause, 停顿时间| 决定了开始一个新循环中要等待多长时间。这个数值n的含义是，当启动下一轮收集循环时内存使用达到了上一轮收集接受后的`n%`。数值越小越激进，调用也就越多。小于等于100的值意味着不会等待就会开始一轮新循环。默认值200，最大值1000。|
|the garbage-collector step multiplier, 乘数|乘数决定了，收集器的相对于内存分配的速度，更具体地说，为每分配1KB内存标记或者扫描了多少元素。数值越大越激进，同时会增加每个增量步长。不应该使用小于100的值，因为会使收集器太慢以致于难以完成一轮循环。默认值100，最大值1000。
|the garbage-collector step size, 步长|步长控制了每个增量步长大小，具体来说，解释器执行每个步骤前分配的字节数。这个参数是对数的，数值n表示`2^n`字节。数值太大会使得收集器编程stop-the-world（非增量收集，停止世界式的收集）。默认值是13，也就是说步长大概8KB。

**分代式垃圾收集**：
- 分代收集模式下，垃圾收集器会进行频繁的次要收集（minor collections），这个过程仅仅遍历最近创建的对象。
- 如果一个次要收集之后内存依然在超过限制，那么会进行停止世界的主要收集（stop-the-world major collection），这个过程会遍历所有对象。
- 有两个参数控制：

|参数|含义|
|:-|:-|
|minor multiplier, 次要乘数|控制次要收集的频率，对于次要乘数`x`，当内存增长到超过上一次主要收集后内存`x%`之后就会触发次要收集。默认值20，最大值200。
|major multiplier, 主要乘数|控制主要收集的频率，对于主要乘数`x`，当内存增长到超过上一次主要收集后内存`x%`之后就会触发主要收集。默认值100，最大值1000。

垃圾收集元方法：
- 可以为元表设置GC元方法，以及使用C API为full userdata设置元方法。
- 这些方法称之为finalizer（终结器）。当垃圾收集器检测到对应tabl或者userdata死亡时就会调用他们。
- finalizer使得我们可以使用垃圾收集来管理外部资源，比如关闭文件、网络或者数据库连接、或者释放C中分配的内存。
- 当为一个对象设置元表时，这个元表中有`__gc`域，那么它就被标记为定制终结过程（marked for finalization）。必须设置时就有，如果设置后才添加则不会工作，需要注意！
- 当一个被标记的对象死亡时，并不会立即被垃圾收集器回收。而是被Lua放进一个列表，在回收之后，Lua会遍历这个列表，对每个对象，调用它的元表中的`__gc`方法。如果存在会将对象作为唯一参数传递。
- 在每一个垃圾收集周期中，每一个对象的finalizer被按照mark for finalization的顺序逆序调用。finalizer可能在常规代码的执行过程中触发。
- 由于对象会被传入finalizer中执行，所以这个对象和它能访问的所有对象都会被Lua复活。这种复活是短暂的。它的内存会在下一个垃圾回收循环中被回收。但是如果这个finalizer中将这个对象存在了某些全局空间中（比如全局变量），那么这种复活就变成了永久的。而且在它再次死亡时，还会再次调用finalizer。
- 当使用`lua_close`关闭一个状态时，Lua会为所有标记终结的对象调用终结器，按照标记的逆序。如果在其中某个finalizer标记对象为回收，那么这种标记不会产生任何效果。
- 终结器不能yield或者运行垃圾收集，因为他们可能运行的次数是不可预测的。
- 最佳实践：保持每个终结器为足以释放资源的必要的最小状态。
- 终结器运行期间抛出的错误会生成一个警告，而不会传播。

弱表（weak tables）：
- 弱表中保存弱引用，弱引用不会会被垃圾收集器忽略。仅有弱引用指向的对象会被回收。
- 弱表中，可以包含弱键和弱值（weak keys and weak values）或者两者，弱智可以使得一个table可以引用自己。
- 在任何情况下，如果键或者值的其中一方被收集，那么这个键值对会直接从表中移除。
- 弱表的模式（键或者值还是两者都为弱引用）有元表的`__mode`来表示。这个项如果存在，比如为吓着之一：`"k" "v" "kv"`表示仅键、仅值、键值均为弱引用。
- 弱键强值称之为ephemeron table。
- 对table的弱表模式的改变仅会在下一轮回收循环中生效。到下一轮循环之前被标记回收的对象在下一轮循环依然会被回收。
- 仅仅只有显式构造的对象会从弱表中溢出。数值、C函数等不会被提交到垃圾收集也就不会被回收（除非他们关联的值被回收）。字符串虽然会被回收，但是没有显式构造且通过值来比较他们，所以他们表现得更像值类型而不是引用类型。所以也不会被从弱表中移除。

## 2.6 协程

- Lua支持协程，也叫做协作式多线程（collaborative multithreading）。
- Lua中的协程表示一个独立执行的线程。不像多线程系统的抢占式调度，协程仅仅在显式调用`yield`时才会挂起。
- 创建：`coroutine.create`，传入一个函数作为参数，作为协程的主函数，返回一个句柄，类型是`thread`。并不会启动协程。
- 启动或者恢复协程；`coroutine.resume`，将句柄作为第一参数。其他参数会被作为传递个协程主函数的参数。一直运行直到结束或者调用`yield`。
- 终止协程运行：主函数返回，无论显式或者隐式（运行到末尾）。或者异常情况：抛出了一个错误，这种情况下`coroutine.resume`返回`false`和错误对象。这种情况下，协程不会进行栈回溯，这时可以通过调用API检查错误。
- 挂起：`coroutine.yield`，当协程挂起时，`coroutine.resume`返回。即使不在主函数也可以这样做，返回`true`和`coroutine.yield`的值。下一次恢复时，`coroutine.yield`给`resume`的参数，然后开始执行。
- 包装协程：`coroutine.wrap`，就像`create`一样，创建协程，但是返回的不是句柄，而是一个函数，运行这个函数会直接调用`coroutine.resume`，传递个函数的参数则直接传递个`coroutine.resume`。然后`coroutine.wrap`返回`coroutine.resume`的返回值（去掉第一个布尔值之后）。这个函数会将错误直接传递给调用者，这种情况下会直接关闭协程。
- 通过C API创建和控制协程：`lua_newthread lua_resume lua_yield`。
